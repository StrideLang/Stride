
#_domainProcessing _PlatformDomainProcessing {
#	rootDomain: RootDomain
#	domainStreams: [
#		RootDomain #>> AsyncDomain >> SerialDomain
#		 >> AudioDomain;
#		# Should perhaps look like:
#		#SetupDomain >> [AudioDomain, AsyncDomain, SerialDomain];
#		# But for now just setting the domain processing order
#	]
#}

constant _GlobalInitTag {
	value: "GlobalInitialization"
}

_frameworkDescription _RtAudioFramework {
    frameworkName: "RtAudio"
}

alias PlatformDomain {
    block: AudioDomain
}

alias PlatformRate {
    block: AudioRate
}

#alias _ContextInitDomain {
#    block: RootDomain
#}

_domainDefinition RootDomain {
	domainName: "RootDomain"
	framework: _RtAudioFramework
	rate: -1 # -1 is 'one-shot/final' domain
	globalsTag: "Includes"
	declarationsTag: "Declarations"
	processingTag: "Includes"
	initializationTag: "Instances"
	cleanupTag: "Processing"
    substitutions: [ ]
    domainIncludes: ["ReadWriteClasses.hpp",
	"Synchronization.hpp",
	"Helper.hpp"]
	domainFunction: '

//[[Declarations]]
//[[/Declarations]]

//[[Instances]]
//[[/Instances]]

//[[Processing]]
//[[/Processing]]

int main() {
//[[GlobalInitialization]]
//[[/GlobalInitialization]]
//[[Initialization]]
//[[/Initialization]]


    char input;
    std::cout << "\nRunning ... press <enter> to quit.\n";
    std::cin.get(input);


//[[Cleanup]]
//[[/Cleanup]]
    return 0;
}
'
  domainCleanup: '// setup domain cleanup'
}

constant AsyncRate {
	value: 1000
}

_domainDefinition AsyncDomain {
	domainName: "AsyncDomain"
	framework: _RtAudioFramework
	parentDomain: RootDomain
	rate: AsyncRate
	globalsTag: "Includes"
	declarationsTag: "Declarations"
	processingTag: "Processing"
	initializationTag: "Initialization"
	cleanupTag: "Cleanup"
    substitutions: ["domain_rate", AsyncDomain.rate ]
    domainIncludes: ['thread', 'chrono', 'iostream']
    domainDeclarations: ["void thread_func();",
		"std::thread asyncthread(thread_func);",
		"bool asyncthread_running {true};"]
    domainInitialization: "// init domain init\n"
	domainFunction: "// async domain processing
	void thread_func() {
		const int duration_ns = 1.0e9/%%domain_rate%%;
		while (asyncthread_running) {
			std::chrono::time_point<std::chrono::system_clock> start_time = std::chrono::system_clock::now();
//[[Processing]]
//[[/Processing]]
			// TODO add overrun check
	auto end_time = start_time + std::chrono::nanoseconds(duration_ns);
    std::this_thread::sleep_until(end_time);

			}
}
	// end async domain processing
	"
    domainCleanup: '// init domain cleanup
	asyncthread_running = false;
	asyncthread.join();
	std::cout << "Thread joined." << std::endl;
	'
}

constant _SerialBaudRate  { # Overriden by configuration
	value: 9600
}

constant _SerialPort  { # Overriden by configuration
	value: '"/dev/ttyACM0"'
}

constant SerialProcessRate {
	value: 1000
}

_domainDefinition SerialDomain {
	domainName: "SerialDomain"
	framework: _RtAudioFramework
	parentDomain: RootDomain
	rate: SerialProcessRate
	globalsTag: "Includes"
	declarationsTag: "Declarations"
	processingTag: "Processing"
	initializationTag: "Initialization"
	cleanupTag: "Cleanup"
    substitutions: ["baud_rate", _SerialBaudRate,
					"serial_port", _SerialPort,
					"serial_process_rate", SerialProcessRate ]
    domainIncludes: ['serial/serial.h', 'thread']
    domainDeclarations: ["void serial_thread_func();",
		"bool serialthread_running {true};",
		"std::thread serialReadThread(serial_thread_func);",
		"serial::Serial serialPort(%%serial_port%%, %%baud_rate%%, serial::Timeout::simpleTimeout(1.0/%%serial_process_rate%%));"]
    domainInitialization: "// serial domain init"
	domainFunction: "
void serial_thread_func() {
		std::string mLineBuffer;
		int mGranularity = 1000000.0/%%serial_process_rate%%; // nanoseconds
//[[Initialization]]
//[[/Initialization]]
  // Flush buffers
  //my_serial.flush();
  std::string lineBuffer; // Stores partial lines between reads
  const unsigned int bufferSize = 4096;
  uint8_t buffer[bufferSize];
  while (serialthread_running) {
    //        size_t bytes_wrote = my_serial.write(test_string);
    auto nextTime = std::chrono::high_resolution_clock::now() + std::chrono::nanoseconds(mGranularity);
    try {
      size_t count = serialPort.read(buffer, bufferSize);
//      mRingBuffer.write((char *) buffer, count);
//      onInput(buffer, count);
				
	if (count > 0) {
    size_t start = 0;
    size_t nullPos = 0;
    while(nullPos <= count) {
      if (buffer[nullPos] == '\n' || buffer[nullPos] == '\r') {
        buffer[nullPos] = '\0';
        char *thisLine = (char *) buffer + start;
        mLineBuffer += std::string(thisLine);
        if (mLineBuffer.size() > 0) {
          // Process line
			auto separatorIndex = mLineBuffer.find(':');
      		size_t _id = std::stoi(mLineBuffer.substr(0, separatorIndex));
      		std::string _value = mLineBuffer.substr(separatorIndex + 1);
      		float serialVar = std::stof(_value);				
//[[Processing]]
//[[/Processing]]
          	mLineBuffer.clear();
        }
        start = nullPos + 1;
      }
      nullPos++;
    }
    if (start < count) {
      char *thisLine = (char *) buffer + start;
      buffer[count] = '\0';
      mLineBuffer += std::string(thisLine);
    }
  }
      std::this_thread::sleep_until(nextTime);
    } catch (const serial::PortNotOpenedException &/*e*/) {
      serialthread_running = false;

    } catch (const serial::IOException &/*e*/) {
      serialthread_running = false;

    }
  }
}
	"
    domainCleanup: '// init domain cleanup
	serialthread_running = false;
	serialReadThread.join();
	std::cout << "Serial Thread joined." << std::endl;
	'
}

_domainDefinition SerialChannelDomain {
	domainName: "SerialChannelDomain"
	framework: _RtAudioFramework
	parentDomain: SerialDomain
	maxInstances: none
	rate: 0
	globalsTag: "Includes"
	declarationsTag: "Declarations"
	processingTag: "Processing"
	initializationTag: "Initialization"
	cleanupTag: "Cleanup"
    domainInitialization: "// serial channel domain init"
	domainFunction: "// serial channel processing function"
    domainCleanup: '// serial channel domain cleanup'
}
