# Buses ------------------

busType ST_AHB {
}

busType ST_APB {
}
# ---- NIVC

nvicType ST_NVIC_TYPE {
    pendingRegister: ST_EXTI_PR
    risingTriggerRegister: ST_EXTI_RTSR
    fallingTriggerRegister: ST_EXTI_FTSR
    registers: [ST_EXTI_IMR]
    meta: "ST nvic"
    inherits: ARM_M4_NVIC
}

hwGenericMapping ST_EXTI_IMRX_MAP {
    generic: GENERIC_INTERRUPT_MASK
    size: 1
    values: [0, 1]
}

registerValue ST_EXTI_IMRX {
    name: "MODER"
    offset: 0x00
    length: 22
    mapsTo: ST_EXTI_IMRX_MAP
}

register ST_EXTI_IMR {
    name: "EXTI_IMR"
    offset: 0x00
    length: 32
    resetValue: 0x00000000
    values: [
        ST_EXTI_IMRX
    ]
    meta: "MRx: Interrupt mask on line x
    0: Interrupt request from line x is masked
    1: Interrupt request from line x is not masked"
    sourcePages: []
}

register ST_EXTI_PR {
    name: "EXTI_PR"
    offset: 0x14
    length: 22
    resetValue: 0x00000000
    values: [
    ]
    meta: "PRx: Pending bit
    0: No trigger request occurred
    1: selected trigger request occurred
    This bit is set when the selected edge event arrives on the external interrupt line.
    This bit is cleared by programming it to '1'."
    sourcePages: []
}

register ST_EXTI_RTSR {
    name: "EXTI_RTSR"
    offset: 0x08
    length: 22
    resetValue: 0x00000000
    values: [
    ]
    meta: "TRx: Rising trigger event configuration bit of line x
    0: Rising trigger disabled (for Event and Interrupt) for input line
    1: Rising trigger enabled (for Event and Interrupt) for input line
    
    Note:
    The external wakeup lines are edge triggered, no glitch must be generated on these lines.
    If a rising edge occurs on the external interrupt line while writing to the EXTI_RTSR register, the pending bit is be set.Rising and falling edge triggers can be set for the same interrupt line. In this configuration, both generate a trigger condition
    "
    sourcePages: [385]
}

register ST_EXTI_FTSR {
    name: "EXTI_FTSR"
    offset: 0x0C
    length: 22
    resetValue: 0x00000000
    values: [
    ]
    meta: "TRx: Falling trigger event configuration bit of line x
    0: Falling trigger disabled (for Event and Interrupt) for input line
    1: Falling trigger enabled (for Event and Interrupt) for input line.
    
    Note:
    The external wakeup lines are edge triggered, no glitch must be generated on these lines.
    If a falling edge occurs on the external interrupt line while writing to the EXTI_RTSR register, the pending bit is be set.Rising and falling edge triggers can be set for the same interrupt line. In this configuration, both generate a trigger condition
    "
    sourcePages: [385]
}

# ---- GPIO

peripheralType ST_GPIO_ST_PIN {
    group: "GPIO PIN"
    registers: []
    genericPeripheral: GENERIC_GPIO_PIN
}

peripheralPin ST_PIN {
    name: ""
    offset: 0x0
    type: ST_GPIO_ST_PIN
}

gpioType ST_GPIO_A {
    group: "GPIO"
    generic: GENERIC_GPIO
    registers: [
        ST_GPIO_MODER_A, ST_GPIO_OTYPER, ST_GPIO_PUPDR, ST_GPIO_ODR, ST_GPIO_IDR
    ]
    readRegisters: [ ST_GPIO_IDR ]
    writeRegisters: [ ST_GPIO_ODR ]
}

gpioType ST_GPIO_X {
    group: "GPIO"
    generic: GENERIC_GPIO
    registers: [
        ST_GPIO_MODER_X, ST_GPIO_OTYPER, ST_GPIO_PUPDR, ST_GPIO_ODR, ST_GPIO_IDR
    ]
    readRegisters: [ ST_GPIO_IDR ]
    writeRegisters: [ ST_GPIO_ODR ]
}

# ----- OTYPER
register ST_GPIO_MODER_A {
    name: "MODER"
    offset: 0x00
    length: 32
    resetValue: 0xEBFFFFFF
    values: [
        ST_GPIO_MODERX
    ]
    meta: "GPIO port mode register
00: Input mode
01: General purpose output mode
10: Alternate function mode
11: Analog mode (reset state)
"
    sourcePages: []
}

hwGenericMapping ST_GPIO_PIN_MODE {
    generic: GENERIC_GPIO_PIN_MODE
    size: 2
    values: [0, 1, 2, 3]
}

registerValue ST_GPIO_MODERX {
    name: "MODER"
    offset: 0
    length: 32
    mapsTo: ST_GPIO_PIN_MODE
}

register ST_GPIO_MODER_X {
    resetValue: 0xFFFFFFFF
    inherits: ST_GPIO_MODER_A
}

# ----- OTYPER

register ST_GPIO_OTYPER {
    name: "OTYPER"
    offset: 0x04
    length: 16
    resetValue: 0x00000000
    values: [
        ST_GPIO_OTX, ST_GPIO_OTYPER_RESERVED
    ]
    meta: "GPIO port output type register
[0:15] 16 values:
  0: Output push-pull (reset state)
  1: Output open-drain

[16:31] Reserved, must be kept at reset value"
    sourcePages: []
}

hwGenericMapping ST_GPIO_PIN_OUTPUT_TYPE {
    generic: GENERIC_GPIO_PIN_OUTPUT_TYPE
    size: 1
    values: [0, 1]
}

registerValue ST_GPIO_OTX {
    name: "OT"
    offset: 0
    length: 16
    mapsTo: ST_GPIO_PIN_OUTPUT_TYPE
}

registerValue ST_GPIO_OTYPER_RESERVED {
    name: "OTYPER_RESERVED"
    offset: 16
    length: 16
    mapsTo: none
    meta: "Reserved, must be kept at reset value"
}


# ---------------------------------------
register ST_GPIO_PUPDR {
    name: "PUPDR"
    offset: 0x0C
    length: 32
    resetValue: 0x24000000
    values: [
        ST_GPIO_PUPDRX
    ]
    meta: "GPIO port pull-up/pull-down register
[31:0] 16 values:

  0: No pull-up, pull-down
  1: Pull-up
  2: Pull-down
  3: Reserved
"

}

hwGenericMapping ST_GPIO_PIN_PULL_UP_DOWN {
    generic: GENERIC_GPIO_PIN_PULL_UP_DOWN
    size: 2
    values: [0, 1, 2]
}

registerValue ST_GPIO_PUPDRX {
    name: "PUPDR"
    offset: 0
    length: 32
    mapsTo: ST_GPIO_PIN_PULL_UP_DOWN
}

# ------- GPIO_ODR
register ST_GPIO_ODR {
    name: "ODR"
    offset: 0x14
    length: 32
    resetValue: 0x00000000
    values: [
        ST_GPIO_ODR
    ]
    meta: "ODRy: Port output data (y = 0..15)
    These bits can be read and written by software.
    Note:   For atomic bit set/reset, the ODR bits can be individually set
    and reset by writing to the GPIOx_BSRR register (x = A..I/J/K)"
    sourcePages: [283]
}

registerValue ST_GPIO_ODR {
    name: "ODR"
    offset: 0
    length: 16
    mapsTo: none # Do we need to connect to specify this mapping, or leave hardcoded as is in C++?
}


# ------- GPIO_ODR
register ST_GPIO_IDR {
    name: "IDR"
    offset: 0x10
    length: 32
    resetValue: 0x00000000
    values: [
        ST_GPIO_IDR
    ]
    meta: "DRy: Port input data (y = 0..15)
    These bits are read-only and can be accessed in word mode only. 
    They contain the input value of the corresponding I/O port."
    sourcePages: [283]
}

registerValue ST_GPIO_IDR {
    name: "IDR"
    offset: 0
    length: 16
    mapsTo: none # Do we need to connect to specify this mapping, or leave hardcoded as is in C++?
}

# SYSCFG #####################################################

peripheralType ST_SYSCFG_TYPE {
    group: "SYSCFG"
    registers: [ST_SYSCFG_EXTICR1]
    genericPeripheral: GENERIC_SYSCFG
}

register ST_SYSCFG_EXTICR1 {
    name: "EXTCR1"
    offset: 0x08
    length: 32
    resetValue: 0x00000000
    values: [
        ST_SYSCFG_EXTICR1_EXTI0
    ]
    meta: "SYSCFG external interrupt configuration register 1"

    sourcePages: [827]
}

registerValue ST_SYSCFG_EXTICR1_EXTI0 {
    name: "EXTI0"
    offset: 0
    length: 4
    mapsTo: none
    valueNames: ["PA[x] pin", "PB[x] pin", "PC[x] pin", "PD[x] pin", "PE[x] pin", "PF[x] pin", "PG[x] pin", "PH[x] pin", "PI[x] pin"]
    meta: "Bits 15:0 EXTIx[3:0]: EXTI x configuration (x = 0 to 3)
    These bits are written by software to select the source input for the EXTIx external interrupt.
    0000: PA[x] pin
    0001: PB[x] pin
    0010: PC[x] pin
    0011: PD[x] pin
    0100: PE[x] pin
    0101: PF[x] pin
    0110: PG[x] pin
    0111: PH[x] pin
    1000: PI[x] pin
"
}

# USART #####################################################

peripheralType ST_USART {
    group: "USART"
    registers: [USART_CR1, USART_BRR]
    genericPeripheral: GENERIC_USART
}

peripheral USART1 {
    name: "USART1"
    offset: 0x40013800
    type: ST_USART
    pinsRequired: ["USART1_TX", "USART1_RX", "USART1_CTS", "USART1_RTS"]
}

peripheral USART2 {
    name: "USART2"
    offset: 0x40004400
    type: ST_USART
    pinsRequired: ["USART2_TX", "USART2_RX", "USART2_CTS", "USART2_RTS"]
}

register USART_CR1 {
    name: "CR1"
    offset: 0x00
    length: 32
    resetValue: 0x00000000
    values: [
        USART_CR1_UE, USART_CR1_UESM, USART_CR1_RE, USART_CR1_TE
    ]
    meta: "USART control register 1"

    sourcePages: [827]
}

registerValue USART_CR1_UE {
    name: "UE"
    offset: 0
    length: 1
    mapsTo: none
    valueNames: ["USART disabled", "USART enabled" ]
    meta: "USART enable

When this bit is cleared, the USART prescalers and outputs are stopped immediately, and all
current operations are discarded. The USART configuration is kept, but all the USART_ISR
status flags are reset. This bit is set and cleared by software.

0: USART prescaler and outputs disabled, low-power mode
1: USART enabled

Note: To enter low-power mode without generating errors on the line, the TE bit must be
previously reset and the software must wait for the TC bit in the USART_ISR to be set
before resetting the UE bit.
The DMA requests are also reset when UE = 0 so the DMA channel must be disabled
before resetting the UE bit.
In Smartcard mode, (SCEN = 1), the SCLK is always available when CLKEN = 1,
regardless of the UE bit value.
"
}

registerValue USART_CR1_UESM {
    name: "UESM"
    offset: 1
    length: 1
    mapsTo: none
    valueNames: ["USART not able to wake up the MCU", "USART able to wake up the MCU" ]
    meta: "USART enable in low-power mode

When this bit is cleared, the USART cannot wake up the MCU from low-power mode.
When this bit is set, the USART can wake up the MCU from low-power mode.
This bit is set and cleared by software.

0: USART not able to wake up the MCU from low-power mode.
1: USART able to wake up the MCU from low-power mode.

Note: It is recommended to set the UESM bit just before entering low-power mode and clear it
when exit from low-power mode.

If the USART does not support the wakeup from Stop feature, this bit is reserved and
must be kept at reset value. Refer to Section 26.4: USART implementation on page 777.
"
}

registerValue USART_CR1_RE {
    name: "RE"
    offset: 2
    length: 1
    mapsTo: none
    valueNames: ["Receiver is disabled", "Receiver is enabled" ]
    meta: "Receiver enable
This bit enables the receiver. It is set and cleared by software.
0: Receiver is disabled
1: Receiver is enabled and begins searching for a start bit
"
}

registerValue USART_CR1_TE {
    name: "TE"
    offset: 3
    length: 1
    mapsTo: none
    valueNames: ["Transmitter is disabled", "Transmitter is enabled" ]
    meta: "Transmitter enable
This bit enables the transmitter. It is set and cleared by software.
0: Transmitter is disabled
1: Transmitter is enabled
Note: During transmission, a low pulse on the TE bit (‘0’ followed by ‘1’) sends a preamble
(idle line) after the current word, except in Smartcard mode. In order to generate an idle
character, the TE must not be immediately written to ‘1’. To ensure the required duration,
the software can poll the TEACK bit in the USART_ISR register.
In Smartcard mode, when TE is set, there is a 1 bit-time delay before the transmission
starts.
"
}


# =====

register USART_BRR {
    name: "BRR"
    offset: 0x0C
    length: 32
    resetValue: 0x00000000
    values: [
        USART_BRR_VALUE
    ]
    meta: "USART baud rate register
BRR[15:0]: USART baud rate
BRR[15:4]
BRR[15:4] = USARTDIV[15:4]
BRR[3:0]
When OVER8 = 0, BRR[3:0] = USARTDIV[3:0].
When OVER8 = 1:
BRR[2:0] = USARTDIV[3:0] shifted 1 bit to the right.
BRR[3] must be kept cleared
"
    sourcePages: [182]
}

registerValue USART_BRR_VALUE {
    name: "BRR"
    offset: 0
    length: 16
    mapsTo: none
    #valueNames: ["Output push-pull", "Output Open drain" ]
    meta: "USART_BRR value"
}


############################## ------------
# DMA

# Source RM0090 Rev 19
dmaType ST_F4_DMA_TYPE {
    group: "DMA"
    registers: [ST_F4_DMA_LISR, ST_F4_DMA_HISR, ST_F4_DMA_LIFCR, ST_F4_DMA_HIFCR, 
        ST_F4_DMA_S0CR, ST_F4_DMA_S1CR, ST_F4_DMA_S2CR, ST_F4_DMA_S3CR,
        ST_F4_DMA_S4CR, ST_F4_DMA_S5CR, ST_F4_DMA_S6CR, ST_F4_DMA_S7CR,
        ST_F4_DMA_S0NDTR, ST_F4_DMA_S1NDTR, ST_F4_DMA_S2NDTR, ST_F4_DMA_S3NDTR,
        ST_F4_DMA_S4NDTR, ST_F4_DMA_S5NDTR, ST_F4_DMA_S6NDTR, ST_F4_DMA_S7NDTR, 
        ST_F4_DMA_S0PAR, ST_F4_DMA_S1PAR, ST_F4_DMA_S2PAR, ST_F4_DMA_S3PAR,
        ST_F4_DMA_S4PAR, ST_F4_DMA_S5PAR, ST_F4_DMA_S6PAR, ST_F4_DMA_S7PAR,
        ST_F4_DMA_S0M0AR, ST_F4_DMA_S1M0AR, ST_F4_DMA_S2M0AR, ST_F4_DMA_S3M0AR, 
        ST_F4_DMA_S4M0AR, ST_F4_DMA_S5M0AR, ST_F4_DMA_S6M0AR, ST_F4_DMA_S7M0AR,
        ST_F4_DMA_S0M1AR, ST_F4_DMA_S1M1AR, ST_F4_DMA_S2M1AR, ST_F4_DMA_S3M1AR, 
        ST_F4_DMA_S4M1AR, ST_F4_DMA_S5M1AR, ST_F4_DMA_S6M1AR, ST_F4_DMA_S7M1AR,
        ST_F4_DMA_S0FCR, ST_F4_DMA_S1FCR, ST_F4_DMA_S2FCR, ST_F4_DMA_S3FCR,
        ST_F4_DMA_S4FCR, ST_F4_DMA_S5FCR, ST_F4_DMA_S6FCR, ST_F4_DMA_S7FCR 
    ]
    genericPeripheral: GENERIC_DMA
    procedures: []
    streams: [ST_F4_DMA_STREAM_0, ST_F4_DMA_STREAM_1, ST_F4_DMA_STREAM_2, ST_F4_DMA_STREAM_3,
            ST_F4_DMA_STREAM_4, ST_F4_DMA_STREAM_5, ST_F4_DMA_STREAM_6, ST_F4_DMA_STREAM_7 
    ]
    meta: ''
    sourcePages: []
}

dmaStream ST_F4_DMA_STREAM_0 {
    name: "Stream 0"
    registers: [
        ST_F4_DMA_S0CR,ST_F4_DMA_S0NDTR,ST_F4_DMA_S0PAR, ST_F4_DMA_S0M0AR, 
        ST_F4_DMA_S0M1AR, ST_F4_DMA_S0FCR 
    ]
    genericPeripheral: GENERIC_DMA_STREAM
    procedures: [ST_F4_EnableDMAStream]
}

dmaStream ST_F4_DMA_STREAM_1 {
    name: "Stream 1"
    registers: [
        ST_F4_DMA_S1CR,ST_F4_DMA_S1NDTR,ST_F4_DMA_S1PAR, ST_F4_DMA_S1M0AR, 
        ST_F4_DMA_S1M1AR, ST_F4_DMA_S1FCR 
    ]
    genericPeripheral: GENERIC_DMA_STREAM
    procedures: [ST_F4_EnableDMAStream]
}
dmaStream ST_F4_DMA_STREAM_2 {
    name: "Stream 2"
    registers: [
        ST_F4_DMA_S2CR,ST_F4_DMA_S2NDTR,ST_F4_DMA_S2PAR, ST_F4_DMA_S2M0AR, 
        ST_F4_DMA_S2M1AR, ST_F4_DMA_S2FCR 
    ]
    genericPeripheral: GENERIC_DMA_STREAM
    procedures: [ST_F4_EnableDMAStream]
}
dmaStream ST_F4_DMA_STREAM_3 {
    name: "Stream 3"
    registers: [
        ST_F4_DMA_S3CR,ST_F4_DMA_S3NDTR,ST_F4_DMA_S3PAR, ST_F4_DMA_S3M0AR, 
        ST_F4_DMA_S3M1AR, ST_F4_DMA_S3FCR 
    ]
    genericPeripheral: GENERIC_DMA_STREAM
    procedures: [ST_F4_EnableDMAStream]
}
dmaStream ST_F4_DMA_STREAM_4 {
    name: "Stream 4"
    registers: [
        ST_F4_DMA_S4CR,ST_F4_DMA_S4NDTR,ST_F4_DMA_S4PAR, ST_F4_DMA_S4M0AR, 
        ST_F4_DMA_S4M1AR, ST_F4_DMA_S4FCR 
    ]
}
dmaStream ST_F4_DMA_STREAM_5 {
    name: "Stream 5"
    registers: [
        ST_F4_DMA_S5CR,ST_F4_DMA_S5NDTR,ST_F4_DMA_S5PAR, ST_F4_DMA_S5M0AR, 
        ST_F4_DMA_S5M1AR, ST_F4_DMA_S5FCR 
    ]
    genericPeripheral: GENERIC_DMA_STREAM
    procedures: [ST_F4_EnableDMAStream]
}
dmaStream ST_F4_DMA_STREAM_6 {
    name: "Stream 6"
    registers: [
        ST_F4_DMA_S6CR,ST_F4_DMA_S6NDTR,ST_F4_DMA_S6PAR, ST_F4_DMA_S6M0AR, 
        ST_F4_DMA_S6M1AR, ST_F4_DMA_S6FCR 
    ]
    genericPeripheral: GENERIC_DMA_STREAM
    procedures: [ST_F4_EnableDMAStream]
}
dmaStream ST_F4_DMA_STREAM_7 {
    name: "Stream 7"
    registers: [
        ST_F4_DMA_S7CR,ST_F4_DMA_S7NDTR,ST_F4_DMA_S7PAR, ST_F4_DMA_S7M0AR, 
        ST_F4_DMA_S7M1AR, ST_F4_DMA_S7FCR 
    ]
    genericPeripheral: GENERIC_DMA_STREAM
    procedures: [ST_F4_EnableDMAStream]
}

dma ST_F4_DMA1 {
    name: "DMA1"
    offset: 0x0
    type: ST_F4_DMA_TYPE
    meta: ''
}

dma ST_F4_DMA2 {
    name: "DMA2"
    offset: 0x0
    type: ST_F4_DMA_TYPE
    meta: ''
}

# DMA Registers
register ST_F4_DMA_LISR {
    name: "LISR"
    offset: 0x00
    length: 32
    resetValue: 0x00000000
    values: [
        ST_F4_DMA_LISR_FEIF0_VALUE, ST_F4_DMA_LISR_FEIF1_VALUE, ST_F4_DMA_LISR_FEIF2_VALUE, ST_F4_DMA_LISR_FEIF13_VALUE,
        ST_F4_DMA_LISR_DMEIF0_VALUE, ST_F4_DMA_LISR_DMEIF1_VALUE, ST_F4_DMA_LISR_DMEIF2_VALUE, ST_F4_DMA_LISR_DMEIF3_VALUE,
        ST_F4_DMA_LISR_TEIF0_VALUE, ST_F4_DMA_LISR_TEIF1_VALUE, ST_F4_DMA_LISR_TEIF2_VALUE, ST_F4_DMA_LISR_TEIF3_VALUE,
        ST_F4_DMA_LISR_HTIF0_VALUE, ST_F4_DMA_LISR_HTIF1_VALUE,ST_F4_DMA_LISR_HTIF2_VALUE,ST_F4_DMA_LISR_HTIF3_VALUE,
        ST_F4_DMA_LISR_TCIF0_VALUE, ST_F4_DMA_LISR_TCIF1_VALUE, ST_F4_DMA_LISR_TCIF2_VALUE, ST_F4_DMA_LISR_TCIF3_VALUE
    ]
    meta: "DMA low interrupt status register"
    sourcePages: [325]
}

registerValue ST_F4_DMA_LISR_FEIFx_VALUE {
    name: "FEIFx"
    offset: 0
    length: 1
    mapsTo: none
    mode: "r"
    valueNames: ["No FIFO Error event", "A FIFO Error event occurred" ]
    meta: "Stream x FIFO error interrupt flag (x=3..0)
This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the
DMA_LIFCR register.
0: No FIFO Error event on stream x
1: A FIFO Error event occurred on stream x"
}

registerValue ST_F4_DMA_LISR_FEIF0_VALUE {
    name: "FEIF0"
    offset: 0
    inherits: ST_F4_DMA_LISR_FEIFx_VALUE
}
registerValue ST_F4_DMA_LISR_FEIF1_VALUE {
    name: "FEIF1"
    offset: 6
    inherits: ST_F4_DMA_LISR_FEIFx_VALUE
}

registerValue ST_F4_DMA_LISR_FEIF2_VALUE {
    name: "FEIF2"
    offset: 16
    inherits: ST_F4_DMA_LISR_FEIFx_VALUE
}
registerValue ST_F4_DMA_LISR_FEIF13_VALUE {
    name: "FEIF3"
    offset: 22
    inherits: ST_F4_DMA_LISR_FEIFx_VALUE
}

registerValue ST_F4_DMA_LISR_DMEIFx_VALUE {
    name: "DMEIFx"
    offset: 2
    length: 1
    mapsTo: none
    mode: "r"
    valueNames: ["No Direct Mode Error", "Direct Mode Error" ]
    meta: "Stream x direct mode error interrupt flag (x=3..0)
This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the
DMA_LIFCR register.
0: No Direct Mode Error on stream x
1: A Direct Mode Error occurred on stream x"
}

registerValue ST_F4_DMA_LISR_DMEIF0_VALUE {
    name: "DMEIF0"
    offset: 2
    inherits: ST_F4_DMA_LISR_DMEIFx_VALUE
}

registerValue ST_F4_DMA_LISR_DMEIF1_VALUE {
    name: "DMEIF1"
    offset: 8
    inherits: ST_F4_DMA_LISR_DMEIFx_VALUE
}

registerValue ST_F4_DMA_LISR_DMEIF2_VALUE {
    name: "DMEIF2"
    offset: 18
    inherits: ST_F4_DMA_LISR_DMEIFx_VALUE
}

registerValue ST_F4_DMA_LISR_DMEIF3_VALUE {
    name: "DMEIF3"
    offset: 24
    inherits: ST_F4_DMA_LISR_DMEIFx_VALUE
}

registerValue ST_F4_DMA_LISR_TEIFx_VALUE {
    name: "TEIFx"
    offset: 3
    length: 1
    mapsTo: none
    mode: "r"
    valueNames: ["No transfer Error", "Transfer Error" ]
    meta: "Stream x transfer error interrupt flag (x=3..0)
This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the
DMA_LIFCR register.
0: No transfer error on stream x
1: A transfer error occurred on stream x"
}

registerValue ST_F4_DMA_LISR_TEIF0_VALUE {
    name: "TEIF0"
    offset: 3
    inherits: ST_F4_DMA_LISR_TEIFx_VALUE
}
registerValue ST_F4_DMA_LISR_TEIF1_VALUE {
    name: "TEIF1"
    offset: 9
    inherits: ST_F4_DMA_LISR_TEIFx_VALUE
}
registerValue ST_F4_DMA_LISR_TEIF2_VALUE {
    name: "TEIF2"
    offset: 19
    inherits: ST_F4_DMA_LISR_TEIFx_VALUE
}
registerValue ST_F4_DMA_LISR_TEIF3_VALUE {
    name: "TEIF3"
    offset: 25
    inherits: ST_F4_DMA_LISR_TEIFx_VALUE
}

registerValue ST_F4_DMA_LISR_HTIFx_VALUE {
    name: "HTIFx"
    offset: 34
    length: 1
    mapsTo: none
    mode: "r"
    valueNames: ["No half transfer event", "Half Transfer Event" ]
    meta: "Stream x half transfer interrupt flag (x=3..0)
This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the
DMA_LIFCR register.
0: No half transfer event on stream x
1: A half transfer event occurred on stream x"
}

registerValue ST_F4_DMA_LISR_HTIF0_VALUE {
    name: "HTIF0"
    offset: 4
    inherits: ST_F4_DMA_LISR_HTIFx_VALUE
}

registerValue ST_F4_DMA_LISR_HTIF1_VALUE {
    name: "HTIF1"
    offset: 10
    inherits: ST_F4_DMA_LISR_HTIFx_VALUE
}

registerValue ST_F4_DMA_LISR_HTIF2_VALUE {
    name: "HTIF2"
    offset: 20
    inherits: ST_F4_DMA_LISR_HTIFx_VALUE
}

registerValue ST_F4_DMA_LISR_HTIF3_VALUE {
    name: "HTIF3"
    offset: 26
    inherits: ST_F4_DMA_LISR_HTIFx_VALUE
}

registerValue ST_F4_DMA_LISR_TCIFx_VALUE {
    name: "TCIFx"
    offset: 34
    length: 1
    mapsTo: none
    mode: "r"
    valueNames: ["No transfer complete event", "Transfer Complete Event" ]
    meta: "Stream x transfer complete interrupt flag (x = 3..0)
This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the
DMA_LIFCR register.
0: No transfer complete event on stream x
1: A transfer complete event occurred on stream x"
}

registerValue ST_F4_DMA_LISR_TCIF0_VALUE {
    name: "TCIF0"
    offset: 5
    inherits: ST_F4_DMA_LISR_TCIFx_VALUE
}
registerValue ST_F4_DMA_LISR_TCIF1_VALUE {
    name: "TCIF1"
    offset: 11
    inherits: ST_F4_DMA_LISR_TCIFx_VALUE
}
registerValue ST_F4_DMA_LISR_TCIF2_VALUE {
    name: "TCIF2"
    offset: 21
    inherits: ST_F4_DMA_LISR_TCIFx_VALUE
}
registerValue ST_F4_DMA_LISR_TCIF3_VALUE {
    name: "TCIF3"
    offset: 27
    inherits: ST_F4_DMA_LISR_TCIFx_VALUE
}

# FIXME complete
register ST_F4_DMA_HISR {
    name: "HISR"
    offset: 0x04
    length: 32
    resetValue: 0x00000000
    values: [
        # USART_BRR_VALUE
    ]
    meta: "DMA high interrupt status register"
    sourcePages: [326]
}

# registerValue USART_BRR_VALUE {
#     name: "BRR"
#     offset: 0
#     length: 16
#     mapsTo: none
#     #valueNames: ["Output push-pull", "Output Open drain" ]
#     meta: "USART_BRR value"
# }

# FIXME complete
register ST_F4_DMA_LIFCR {
    name: "LIFCR"
    offset: 0x08
    length: 32
    resetValue: 0x00000000
    values: [
        # USART_BRR_VALUE
    ]
    meta: "DMA low interrupt flag clear register"
    sourcePages: [327]
}

# registerValue USART_BRR_VALUE {
#     name: "BRR"
#     offset: 0
#     length: 16
#     mapsTo: none
#     #valueNames: ["Output push-pull", "Output Open drain" ]
#     meta: "USART_BRR value"
# }

# FIXME complete
register ST_F4_DMA_HIFCR {
    name: "HIFCR"
    offset: 0x0C
    length: 32
    resetValue: 0x00000000
    values: [
        # USART_BRR_VALUE
    ]
    meta: "DMA high interrupt flag clear register"
    sourcePages: [327]
}

# registerValue USART_BRR_VALUE {
#     name: "BRR"
#     offset: 0
#     length: 16
#     mapsTo: none
#     #valueNames: ["Output push-pull", "Output Open drain" ]
#     meta: "USART_BRR value"
# }

register ST_F4_DMA_SxCR {
    name: "SxCR"
    offset: 0x10 # + 0x18 * stream number
    length: 32
    resetValue: 0x00000000
    values: [
        ST_F4_DMA_SxCR_EN_VALUE, ST_F4_DMA_SxCR_DMEIE_VALUE,ST_F4_DMA_SxCR_TEIE_VALUE,
        ST_F4_DMA_SxCR_HTIE_VALUE, ST_F4_DMA_SxCR_TCIE_VALUE, ST_F4_DMA_SxCR_PFCTRL_VALUE,
        ST_F4_DMA_SxCR_DIR_VALUE, ST_F4_DMA_SxCR_CIRC_VALUE, ST_F4_DMA_SxCR_PINC_VALUE,
        ST_F4_DMA_SxCR_MINC_VALUE, ST_F4_DMA_SxCR_MSIZE_VALUE, ST_F4_DMA_SxCR_PSIZE_VALUE, ST_F4_DMA_SxCR_MSIZE_VALUE,
        ST_F4_DMA_SxCR_PINCOS_VALUE, ST_F4_DMA_SxCR_PL_VALUE, ST_F4_DMA_SxCR_DBM_VALUE,
        ST_F4_DMA_SxCR_CT_VALUE, ST_F4_DMA_SxCR_PBURST_VALUE, ST_F4_DMA_SxCR_MBURST_VALUE,
        ST_F4_DMA_SxCR_CHSEL_VALUE
    ]
    meta: "DMA stream x configuration register (DMA_SxCR) (x = 0..7)"
    sourcePages: [328]
}

register ST_F4_DMA_S0CR {
    name: "S0CR"
    offset: 0x10  #0x10  + 0x18 * stream number
    inherits: ST_F4_DMA_SxCR
}

register ST_F4_DMA_S1CR {
    name: "S1CR"
    offset: 0x28 #0x10  + 0x18 * stream number
    inherits: ST_F4_DMA_SxCR
}

register ST_F4_DMA_S2CR {
    name: "S2CR"
    offset: 0x40 #0x10  + 0x18 * stream number
    inherits: ST_F4_DMA_SxCR
}

register ST_F4_DMA_S3CR {
    name: "S3CR"
    offset: 0x58 #0x10  + 0x18 * stream number
    inherits: ST_F4_DMA_SxCR
}

register ST_F4_DMA_S4CR {
    name: "S4CR"
    offset: 0x70 #0x10  + 0x18 * stream number
    inherits: ST_F4_DMA_SxCR
}

register ST_F4_DMA_S5CR {
    name: "S5CR"
    offset: 0x88 #0x10  + 0x18 * stream number
    inherits: ST_F4_DMA_SxCR
}

register ST_F4_DMA_S6CR {
    name: "S6CR"
    offset: 0xA0 #0x10  + 0x18 * stream number
    inherits: ST_F4_DMA_SxCR
}

register ST_F4_DMA_S7CR {
    name: "S7CR"
    offset: 0xB8 #0x10  + 0x18 * stream number
    inherits: ST_F4_DMA_SxCR
}

registerValue ST_F4_DMA_SxCR_CHSEL_VALUE {
    name: "CHSEL"
    offset: 25
    length: 3
    mapsTo: none
    valueNames: ["channel 0", "channel 1","channel 2", "channel 3",
            "channel 4", "channel 5", "channel 6", "channel 7"]
    meta: "Channel selection
These bits are set and cleared by software.
000: channel 0 selected
001: channel 1 selected
010: channel 2 selected
011: channel 3 selected
100: channel 4 selected
101: channel 5 selected
110: channel 6 selected
111: channel 7 selected
These bits are protected and can be written only if EN is ‘0’"
}

registerValue ST_F4_DMA_SxCR_MBURST_VALUE {
    name: "MBURST"
    offset: 23
    length: 2
    mapsTo: none
    valueNames: ["single transfer", "INCR4", "INCR8", "INCR16"]
    meta: "Memory burst transfer configuration
These bits are set and cleared by software.
00: single transfer
01: INCR4 (incremental burst of 4 beats)
10: INCR8 (incremental burst of 8 beats)
11: INCR16 (incremental burst of 16 beats)
These bits are protected and can be written only if EN is ‘0’
In direct mode, these bits are forced to 0x0 by hardware as soon as bit EN= '1'."
}

registerValue ST_F4_DMA_SxCR_PBURST_VALUE {
    name: "PBURST"
    offset: 21
    length: 2
    mapsTo: none
    valueNames: ["single transfer", "INCR4", "INCR8", "INCR16"]
    meta: "Peripheral burst transfer configuration
These bits are set and cleared by software.
00: single transfer
01: INCR4 (incremental burst of 4 beats)
10: INCR8 (incremental burst of 8 beats)
11: INCR16 (incremental burst of 16 beats)
These bits are protected and can be written only if EN is ‘0’
In direct mode, these bits are forced to 0x0 by hardware."
}

registerValue ST_F4_DMA_SxCR_CT_VALUE {
    name: "CT"
    offset: 19
    length: 1
    mapsTo: none
    valueNames: ["Memory 0", "Memory1"]
    meta: "Current target (only in double buffer mode)
This bits is set and cleared by hardware. It can also be written by software.
0: The current target memory is Memory 0 (addressed by the DMA_SxM0AR pointer)
1: The current target memory is Memory 1 (addressed by the DMA_SxM1AR pointer)
This bit can be written only if EN is ‘0’ to indicate the target memory area of the first transfer.
Once the stream is enabled, this bit operates as a status flag indicating which memory area
is the current target."
}

registerValue ST_F4_DMA_SxCR_DBM_VALUE {
    name: "DBM"
    offset: 18
    length: 1
    mapsTo: none
    valueNames: ["No buffer switching", "Memory target switched"]
    meta: "Double buffer mode
This bits is set and cleared by software.
0: No buffer switching at the end of transfer
1: Memory target switched at the end of the DMA transfer
This bit is protected and can be written only if EN is ‘0’."
}

registerValue ST_F4_DMA_SxCR_PL_VALUE {
    name: "PL"
    offset: 16
    length: 2
    mapsTo: none
    valueNames: ["Low", "Medium", "High", "Very high" ]
    meta: "Priority level
These bits are set and cleared by software.
00: Low
01: Medium
10: High
11: Very high
These bits are protected and can be written only if EN is ‘0’."
}

registerValue ST_F4_DMA_SxCR_PINCOS_VALUE {
    name: "PINCOS"
    offset: 15
    length: 1
    mapsTo: none
    valueNames: ["linked to the PSIZE", "fixed to 4 (32-bit alignment)" ]
    meta: "Peripheral increment offset size
This bit is set and cleared by software
0: The offset size for the peripheral address calculation is linked to the PSIZE
1: The offset size for the peripheral address calculation is fixed to 4 (32-bit alignment).
This bit has no meaning if bit PINC = '0'.
This bit is protected and can be written only if EN = '0'.
This bit is forced low by hardware when the stream is enabled (bit EN = '1') if the direct
mode is selected or if PBURST are different from “00”."
}

registerValue ST_F4_DMA_SxCR_MSIZE_VALUE {
    name: "MSIZE"
    offset: 13
    length: 2
    mapsTo: none
    valueNames: ["Byte (8-bit)", "Half-word (16-bit)", "Word (32-bit)", "Reserved" ]
    meta: "Memory data size
These bits are set and cleared by software.
00: byte (8-bit)
01: half-word (16-bit)
10: word (32-bit)
11: reserved
These bits are protected and can be written only if EN is ‘0’.
In direct mode, MSIZE is forced by hardware to the same value as PSIZE as soon as bit EN
= '1'."
}

registerValue ST_F4_DMA_SxCR_PSIZE_VALUE {
    name: "PSIZE"
    offset: 11
    length: 2
    mapsTo: none
    valueNames: ["Byte (8-bit)", "Half-word (16-bit)", "Word (32-bit)", "Reserved" ]
    meta: "Peripheral data size
These bits are set and cleared by software.
00: Byte (8-bit)
01: Half-word (16-bit)
10: Word (32-bit)
11: reserved
These bits are protected and can be written only if EN is ‘0’"
}

registerValue ST_F4_DMA_SxCR_MINC_VALUE {
    name: "MINC"
    offset: 10
    length: 1
    mapsTo: none
    valueNames: ["Fixed", "Incremented after data transfer" ]
    meta: "Memory increment mode
This bit is set and cleared by software.
0: Memory address pointer is fixed
1: Memory address pointer is incremented after each data transfer (increment is done
according to MSIZE)
This bit is protected and can be written only if EN is ‘0’."
}

registerValue ST_F4_DMA_SxCR_PINC_VALUE {
    name: "PINC"
    offset: 9
    length: 1
    mapsTo: none
    valueNames: ["Fixed", "Incremented after data transfer" ]
    meta: "Peripheral increment mode
This bit is set and cleared by software.
0: Peripheral address pointer is fixed
1: Peripheral address pointer is incremented after each data transfer (increment is done
according to PSIZE)
This bit is protected and can be written only if EN is ‘0’."
}

registerValue ST_F4_DMA_SxCR_CIRC_VALUE {
    name: "CIRC"
    offset: 8
    length: 1
    mapsTo: none
    valueNames: ["disabled", "enabled" ]
    meta: "Circular mode
This bit is set and cleared by software and can be cleared by hardware.
0: Circular mode disabled
1: Circular mode enabled
When the peripheral is the flow controller (bit PFCTRL=1) and the stream is enabled (bit
EN=1), then this bit is automatically forced by hardware to 0.
It is automatically forced by hardware to 1 if the DBM bit is set, as soon as the stream is
enabled (bit EN ='1')."
}

registerValue ST_F4_DMA_SxCR_DIR_VALUE {
    name: "DIR"
    offset: 6
    length: 2
    mapsTo: none
    valueNames: ["Peripheral-to-memory", "Memory-to-peripheral", "Memory-to-memory", "Reserved" ]
    meta: "Data transfer direction
These bits are set and cleared by software.
00: Peripheral-to-memory
01: Memory-to-peripheral
10: Memory-to-memory
11: reserved
These bits are protected and can be written only if EN is ‘0’."
}

registerValue ST_F4_DMA_SxCR_PFCTRL_VALUE {
    name: "PFCTRL"
    offset: 5
    length: 1
    mapsTo: none
    valueNames: ["The DMA is the flow controller", "The peripheral is the flow controller" ]
    meta: "Peripheral flow controller
This bit is set and cleared by software.
0: The DMA is the flow controller
1: The peripheral is the flow controller
This bit is protected and can be written only if EN is ‘0’.
When the memory-to-memory mode is selected (bits DIR[1:0]=10), then this bit is
automatically forced to 0 by hardware."
}

registerValue ST_F4_DMA_SxCR_TCIE_VALUE {
    name: "TCIE"
    offset: 4
    length: 1
    mapsTo: none
    valueNames: ["disabled", "enabled" ]
    meta: "Transfer complete interrupt enable
This bit is set and cleared by software.
0: TC interrupt disabled
1: TC interrupt enabled"
}

registerValue ST_F4_DMA_SxCR_HTIE_VALUE {
    name: "HTIE"
    offset: 3
    length: 1
    mapsTo: none
    valueNames: ["disabled", "enabled" ]
    meta: "Half transfer interrupt enable
This bit is set and cleared by software.
0: HT interrupt disabled
1: HT interrupt enabled"
}

registerValue ST_F4_DMA_SxCR_TEIE_VALUE {
    name: "TEIE"
    offset: 2
    length: 1
    mapsTo: none
    valueNames: ["disabled", "enabled" ]
    meta: "Transfer error interrupt enable
This bit is set and cleared by software.
0: TE interrupt disabled
1: TE interrupt enabled"
}

registerValue ST_F4_DMA_SxCR_DMEIE_VALUE {
    name: "DMEIE"
    offset: 1
    length: 1
    mapsTo: none
    valueNames: ["disabled", "enabled" ]
    meta: "Direct mode error interrupt enable
This bit is set and cleared by software.
0: DME interrupt disabled
1: DME interrupt enabled"
}

registerValue ST_F4_DMA_SxCR_EN_VALUE {
    name: "EN"
    offset: 0
    length: 1
    mapsTo: none
    valueNames: ["disabled", "enabled" ]
    meta: "Stream enable / flag stream ready when read low
This bit is set and cleared by software.
0: Stream disabled
1: Stream enabled
This bit may be cleared by hardware:
– on a DMA end of transfer (stream ready to be configured)
– if a transfer error occurs on the AHB master buses
– when the FIFO threshold on memory AHB port is not compatible with the size of the
burst
When this bit is read as 0, the software is allowed to program the Configuration and FIFO
bits registers. It is forbidden to write these registers when the EN bit is read as 1.
Note: Before setting EN bit to '1' to start a new transfer, the event flags corresponding to the
stream in DMA_LISR or DMA_HISR register must be cleared."
}

register ST_F4_DMA_SxNDTR {
    name: "SxNDTR"
    offset: 0x14 # + 0x18 * stream number
    length: 32
    resetValue: 0x00000000
    values: [
        ST_F4_DMA_SxNDTR_NDT_VALUE
    ]
    meta: "DMA stream x number of data register (DMA_SxNDTR) (x = 0..7)"
    sourcePages: [331]
}

register ST_F4_DMA_S0NDTR {
    name: "S0NDTR"
    offset: 0x14  #0x14  + 0x18 * stream number
    inherits: ST_F4_DMA_SxNDTR
}
register ST_F4_DMA_S1NDTR {
    name: "S1NDTR"
    offset: 0x2C  #0x14  + 0x18 * stream number
    inherits: ST_F4_DMA_SxNDTR
}
register ST_F4_DMA_S2NDTR {
    name: "S2NDTR"
    offset: 0x44  #0x14  + 0x18 * stream number
    inherits: ST_F4_DMA_SxNDTR
}
register ST_F4_DMA_S3NDTR {
    name: "S3NDTR"
    offset: 0x5C  #0x14  + 0x18 * stream number
    inherits: ST_F4_DMA_SxNDTR
}
register ST_F4_DMA_S4NDTR {
    name: "S4NDTR"
    offset: 0x74  #0x14  + 0x18 * stream number
    inherits: ST_F4_DMA_SxNDTR
}
register ST_F4_DMA_S5NDTR {
    name: "S5NDTR"
    offset: 0x8C  #0x14  + 0x18 * stream number
    inherits: ST_F4_DMA_SxNDTR
}
register ST_F4_DMA_S6NDTR {
    name: "S6NDTR"
    offset: 0xA4  #0x14  + 0x18 * stream number
    inherits: ST_F4_DMA_SxNDTR
}
register ST_F4_DMA_S7NDTR {
    name: "S7NDTR"
    offset: 0xBC  #0x14  + 0x18 * stream number
    inherits: ST_F4_DMA_SxNDTR
}

registerValue ST_F4_DMA_SxNDTR_NDT_VALUE {
    name: "NDT"
    offset: 0
    length: 16
    mapsTo: none
    #valueNames: ["Output push-pull", "Output Open drain" ]
    meta: "Number of data items to transfer
Number of data items to be transferred (0 up to 65535). This register can be written only
when the stream is disabled. When the stream is enabled, this register is read-only,
indicating the remaining data items to be transmitted. This register decrements after each
DMA transfer.
Once the transfer has completed, this register can either stay at zero (when the stream is in
normal mode) or be reloaded automatically with the previously programmed value in the
following cases:
–
when the stream is configured in Circular mode.
–
when the stream is enabled again by setting EN bit to '1'
If the value of this register is zero, no transaction can be served even if the stream is
enabled."
}


register ST_F4_DMA_SxPAR {
    name: "SxPAR"
    offset: 0x18 # + 0x18 * stream number
    length: 32
    resetValue: 0x00000000
    values: [
        ST_F4_DMA_SxPAR_VALUE
    ]
    meta: "DMA stream x peripheral address register (DMA_SxPAR) (x = 0..7)
    Bits 31:0 PAR[31:0]: Peripheral address
Base address of the peripheral data register from/to which the data will be read/written.
These bits are write-protected and can be written only when bit EN = '0' in the DMA_SxCR register."
    sourcePages: [332]
}

register ST_F4_DMA_S0PAR {
    name: "S0PAR"
    offset: 0x18  #0x18  + 0x18 * stream number
    inherits: ST_F4_DMA_SxPAR
}
register ST_F4_DMA_S1PAR {
    name: "S1PAR"
    offset: 0x30  #0x18  + 0x18 * stream number
    inherits: ST_F4_DMA_SxPAR
}
register ST_F4_DMA_S2PAR {
    name: "S2PAR"
    offset: 0x48  #0x18  + 0x18 * stream number
    inherits: ST_F4_DMA_SxPAR
}
register ST_F4_DMA_S3PAR {
    name: "S3PAR"
    offset: 0x60  #0x18  + 0x18 * stream number
    inherits: ST_F4_DMA_SxPAR
}
register ST_F4_DMA_S4PAR {
    name: "S4PAR"
    offset: 0x78  #0x18  + 0x18 * stream number
    inherits: ST_F4_DMA_SxPAR
}
register ST_F4_DMA_S5PAR {
    name: "S5PAR"
    offset: 0x90  #0x18  + 0x18 * stream number
    inherits: ST_F4_DMA_SxPAR
}
register ST_F4_DMA_S6PAR {
    name: "S6PAR"
    offset: 0xA8  #0x18  + 0x18 * stream number
    inherits: ST_F4_DMA_SxPAR
}
register ST_F4_DMA_S7PAR {
    name: "S7PAR"
    offset: 0xC0  #0x18  + 0x18 * stream number
    inherits: ST_F4_DMA_SxPAR
}

registerValue ST_F4_DMA_SxPAR_VALUE {
    name: "SxPAR"
    offset: 0
    length: 32
    mapsTo: none
    #valueNames: ["Output push-pull", "Output Open drain" ]
    meta: "Base address of the peripheral data register from/to which the data will be read/written.
These bits are write-protected and can be written only when bit EN = '0' in the DMA_SxCR register."
}

register ST_F4_DMA_SxM0AR {
    name: "SxM0AR"
    offset: 0x1C # + 0x18 * stream number
    length: 32
    resetValue: 0x00000000
    values: [
        ST_F4_DMA_SxM0AR_VALUE
    ]
    meta: "Bits 31:0 M0A[31:0]: Memory 0 address
    Base address of Memory area 0 from/to which the data will be read/written.
These bits are write-protected. They can be written only if:
– the stream is disabled (bit EN= '0' in the DMA_SxCR register) or
– the stream is enabled (EN=’1’ in DMA_SxCR register) and bit CT = '1' in the
DMA_SxCR register (in Double buffer mode)."
    sourcePages: [332]
}
register ST_F4_DMA_S0M0AR {
    name: "S0M0AR"
    offset: 0x1C  #0x1C  + 0x18 * stream number
    inherits: ST_F4_DMA_SxM0AR
}
register ST_F4_DMA_S1M0AR {
    name: "S1M0AR"
    offset: 0x34  #0x1C  + 0x18 * stream number
    inherits: ST_F4_DMA_SxM0AR
}
register ST_F4_DMA_S2M0AR {
    name: "S2M0AR"
    offset: 0x4C  #0x1C  + 0x18 * stream number
    inherits: ST_F4_DMA_SxM0AR
}
register ST_F4_DMA_S3M0AR {
    name: "S3M0AR"
    offset: 0x64  #0x1C  + 0x18 * stream number
    inherits: ST_F4_DMA_SxM0AR
}
register ST_F4_DMA_S4M0AR {
    name: "S4M0AR"
    offset: 0x7C  #0x1C  + 0x18 * stream number
    inherits: ST_F4_DMA_SxM0AR
}
register ST_F4_DMA_S5M0AR {
    name: "S5M0AR"
    offset: 0x94  #0x1C  + 0x18 * stream number
    inherits: ST_F4_DMA_SxM0AR
}
register ST_F4_DMA_S6M0AR {
    name: "S6M0AR"
    offset: 0xAC  #0x1C  + 0x18 * stream number
    inherits: ST_F4_DMA_SxM0AR
}
register ST_F4_DMA_S7M0AR {
    name: "S7M0AR"
    offset: 0xC4  #0x1C  + 0x18 * stream number
    inherits: ST_F4_DMA_SxM0AR
}

registerValue ST_F4_DMA_SxM0AR_VALUE {
    name: "SxM0AR"
    offset: 0
    length: 32
    mapsTo: none
    #valueNames: ["Output push-pull", "Output Open drain" ]
    meta: "Memory 0 address
    Base address of Memory area 0 from/to which the data will be read/written.
These bits are write-protected. They can be written only if:
– the stream is disabled (bit EN= '0' in the DMA_SxCR register) or
– the stream is enabled (EN=’1’ in DMA_SxCR register) and bit CT = '1' in the
DMA_SxCR register (in Double buffer mode)."
}

register ST_F4_DMA_SxM1AR {
    name: "SxM1AR"
    offset: 0x1C # + 0x1C * stream number
    length: 32
    resetValue: 0x00000000
    values: [
        ST_F4_DMA_SxM1AR_VALUE
    ]
    meta: "Bits 31:0 M0A[31:0]: Memory 1 address
    Base address of Memory area 0 from/to which the data will be read/written.
These bits are write-protected. They can be written only if:
– the stream is disabled (bit EN= '0' in the DMA_SxCR register) or
– the stream is enabled (EN=’1’ in DMA_SxCR register) and bit CT = '1' in the
DMA_SxCR register (in Double buffer mode)."
    sourcePages: [333]
}
register ST_F4_DMA_S0M1AR {
    name: "S0M1AR"
    offset: 0x20  #0x20  + 0x18 * stream number
    inherits: ST_F4_DMA_SxM1AR
}
register ST_F4_DMA_S1M1AR {
    name: "S1M1AR"
    offset: 0x38  #0x20  + 0x18 * stream number
    inherits: ST_F4_DMA_SxM1AR
}
register ST_F4_DMA_S2M1AR {
    name: "S2M1AR"
    offset: 0x50  #0x20  + 0x18 * stream number
    inherits: ST_F4_DMA_SxM1AR
}
register ST_F4_DMA_S3M1AR {
    name: "S3M1AR"
    offset: 0x68  #0x20  + 0x18 * stream number
    inherits: ST_F4_DMA_SxM1AR
}
register ST_F4_DMA_S4M1AR {
    name: "S4M1AR"
    offset: 0x80  #0x20  + 0x18 * stream number
    inherits: ST_F4_DMA_SxM1AR
}
register ST_F4_DMA_S5M1AR {
    name: "S5M1AR"
    offset: 0x98  #0x20  + 0x18 * stream number
    inherits: ST_F4_DMA_SxM1AR
}
register ST_F4_DMA_S6M1AR {
    name: "S6M1AR"
    offset: 0xB0  #0x20  + 0x18 * stream number
    inherits: ST_F4_DMA_SxM1AR
}
register ST_F4_DMA_S7M1AR {
    name: "S7M1AR"
    offset: 0xC8  #0x20  + 0x18 * stream number
    inherits: ST_F4_DMA_SxM1AR
}

registerValue ST_F4_DMA_SxM1AR_VALUE {
    name: "SxM1AR"
    offset: 0
    length: 32
    mapsTo: none
    #valueNames: ["Output push-pull", "Output Open drain" ]
    meta: "Memory 1 address
    Base address of Memory area 0 from/to which the data will be read/written.
These bits are write-protected. They can be written only if:
– the stream is disabled (bit EN= '0' in the DMA_SxCR register) or
– the stream is enabled (EN=’1’ in DMA_SxCR register) and bit CT = '1' in the
DMA_SxCR register (in Double buffer mode)."
}

register ST_F4_DMA_SxFCR {
    name: "SxFCR"
    offset: 0x24 # + 0x24 * stream number
    length: 32
    resetValue: 0x00000021
    values: [
       ST_F4_DMA_SxFCR_FTH_VALUE, ST_F4_DMA_SxFCR_DMDIS_VALUE, ST_F4_DMA_SxFCR_FS_VALUE
    ]
    meta: "Bits 31:0 M0A[31:0]: Memory 1 address
    Base address of Memory area 0 from/to which the data will be read/written.
These bits are write-protected. They can be written only if:
– the stream is disabled (bit EN= '0' in the DMA_SxCR register) or
– the stream is enabled (EN=’1’ in DMA_SxCR register) and bit CT = '1' in the
DMA_SxCR register (in Double buffer mode)."
    sourcePages: [333]
}
register ST_F4_DMA_S0FCR {
    name: "S0FCR"
    offset: 0x24  #0x24  + 0x24 * stream number
    inherits: ST_F4_DMA_SxFCR
}
register ST_F4_DMA_S1FCR {
    name: "S1FCR"
    offset: 0x3C  #0x24  + 0x24 * stream number
    inherits: ST_F4_DMA_SxFCR
}
register ST_F4_DMA_S2FCR {
    name: "S2FCR"
    offset: 0x54  #0x24  + 0x24 * stream number
    inherits: ST_F4_DMA_SxFCR
}
register ST_F4_DMA_S3FCR {
    name: "S3FCR"
    offset: 0x6C  #0x24  + 0x24 * stream number
    inherits: ST_F4_DMA_SxFCR
}
register ST_F4_DMA_S4FCR {
    name: "S4FCR"
    offset: 0x84  #0x24  + 0x24 * stream number
    inherits: ST_F4_DMA_SxFCR
}
register ST_F4_DMA_S5FCR {
    name: "S5FCR"
    offset: 0x9C  #0x24  + 0x24 * stream number
    inherits: ST_F4_DMA_SxFCR
}
register ST_F4_DMA_S6FCR {
    name: "S6FCR"
    offset: 0xB4  #0x24  + 0x24 * stream number
    inherits: ST_F4_DMA_SxFCR
}
register ST_F4_DMA_S7FCR {
    name: "S7FCR"
    offset: 0xCC  #0x24  + 0x24 * stream number
    inherits: ST_F4_DMA_SxFCR
}


registerValue ST_F4_DMA_SxFCR_FTH_VALUE {
    name: "FTH"
    offset: 0
    length: 2
    mapsTo: none
    #valueNames: ["Output push-pull", "Output Open drain" ]
    meta: "FIFO threshold selection
These bits are set and cleared by software.
00: 1/4 full FIFO
01: 1/2 full FIFO
10: 3/4 full FIFO
11: full FIFO
These bits are not used in the direct mode when the DMIS value is zero.
These bits are protected and can be written only if EN is ‘0’."
}

registerValue ST_F4_DMA_SxFCR_DMDIS_VALUE {
    name: "DMDIS"
    offset: 2
    length: 1
    mapsTo: none
    #valueNames: ["Output push-pull", "Output Open drain" ]
    meta: "Direct mode disable
This bit is set and cleared by software. It can be set by hardware.
0: Direct mode enabled
1: Direct mode disabled
This bit is protected and can be written only if EN is ‘0’.
This bit is set by hardware if the memory-to-memory mode is selected (DIR bit in
DMA_SxCR are “10”) and the EN bit in the DMA_SxCR register is ‘1’ because the direct
mode is not allowed in the memory-to-memory configuration."
}

registerValue ST_F4_DMA_SxFCR_FS_VALUE {
    name: "FS"
    offset: 3
    length: 3
    mapsTo: none
    mode: 'r'
    #valueNames: ["Output push-pull", "Output Open drain" ]
    meta: "FIFO status
These bits are read-only.
000: 0 < fifo_level < 1/4
001: 1/4 ≤ fifo_level < 1/2
010: 1/2 ≤ fifo_level < 3/4
011: 3/4 ≤ fifo_level < full
100: FIFO is empty
101: FIFO is full
others: no meaning
These bits are not relevant in the direct mode (DMDIS bit is zero)."
}

registerValue ST_F4_DMA_SxFCR_FEIE_VALUE {
    name: "FEIE"
    offset: 7
    length: 1
    mapsTo: none
    #valueNames: ["Output push-pull", "Output Open drain" ]
    meta: "FIFO error interrupt enable
This bit is set and cleared by software.
0: FE interrupt disabled
1: FE interrupt enabled"
}

# From RM0090 Rev. 19

#The following sequence should be followed to configure a DMA stream x (where x is the
# stream number):
# 322/1751
# 1. If the stream is enabled, disable it by resetting the EN bit in the DMA_SxCR register,
# then read this bit in order to confirm that there is no ongoing stream operation. Writing
# this bit to 0 is not immediately effective since it is actually written to 0 once all the
# current transfers have finished. When the EN bit is read as 0, this means that the
# stream is ready to be configured. It is therefore necessary to wait for the EN bit to be
# cleared before starting any stream configuration. All the stream dedicated bits set in the
# status register (DMA_LISR and DMA_HISR) from the previous data block DMA
# transfer should be cleared before the stream can be re-enabled.
# 2. Set the peripheral port register address in the DMA_SxPAR register. The data will be
# moved from/ to this address to/ from the peripheral port after the peripheral event.
# 3. Set the memory address in the DMA_SxMA0R register (and in the DMA_SxMA1R
# register in the case of a double buffer mode). The data will be written to or read from
# this memory after the peripheral event.
# 4. Configure the total number of data items to be transferred in the DMA_SxNDTR
# register. After each peripheral event or each beat of the burst, this value is
# decremented.
# 5. Select the DMA channel (request) using CHSEL[2:0] in the DMA_SxCR register.
# 6. If the peripheral is intended to be the flow controller and if it supports this feature, set
# the PFCTRL bit in the DMA_SxCR register.
# 7. Configure the stream priority using the PL[1:0] bits in the DMA_SxCR register.
# 8. Configure the FIFO usage (enable or disable, threshold in transmission and reception)
# 9. Configure the data transfer direction, peripheral and memory incremented/fixed mode,
# single or burst transactions, peripheral and memory data widths, Circular mode,
# RM0090 Rev 19RM0090
# DMA controller (DMA)
# Double buffer mode and interrupts after half and/or full transfer, and/or errors in the
# DMA_SxCR register.
# 10. Activate the stream by setting the EN bit in the DMA_SxCR register.

procedure ST_F4_EnableDMAStream {
    name: "Enable DMA Channel"
    meta: "Procedure to enable DMA Channel"
    actions: [ 
        action DisableStream {
            name: "Disable Stream"
            sequence: [
                resetRegisterValues RESET_EN_BIT {
                    registerValues: [ST_F4_DMA_SxCR_EN_VALUE] 
                    optional: off
                }
                ensureRegisterValues ENSURE_EN_BIT_0 {
                    registerValues: [ST_F4_DMA_SxCR_EN_VALUE] 
                    value: 0
                    optional: off
                    timeout: none
                    waitMethod: none
                }
                resetRegisterValues RESET_xISR_BITS {
                    registerValues: [ST_F4_DMA_LISR_FEIFx_VALUE, ST_F4_DMA_HISR_FEIFx_VALUE,
                                ST_F4_DMA_LISR_DMEIFx_VALUE, ST_F4_DMA_HISR_DMEIFx_VALUE,
                                ST_F4_DMA_LISR_TEIFx_VALUE, ST_F4_DMA_HISR_TEIFx_VALUE,
                                ST_F4_DMA_LISR_HTIFx_VALUE, ST_F4_DMA_HISR_HTIFx_VALUE,
                                ST_F4_DMA_LISR_TCIFx_VALUE, ST_F4_DMA_HISR_TCIFx_VALUE
                    ] 
                    optional: off
                }
                ]
            requiredState: ["Enabled", "1"]
            setsState: ["Enabled", "0"]
            meta: "If the stream is enabled, disable it by resetting the EN bit in the DMA_SxCR register,
then read this bit in order to confirm that there is no ongoing stream operation. Writing
this bit to 0 is not immediately effective since it is actually written to 0 once all the
current transfers have finished. When the EN bit is read as 0, this means that the
stream is ready to be configured. It is therefore necessary to wait for the EN bit to be
cleared before starting any stream configuration. All the stream dedicated bits set in the
status register (DMA_LISR and DMA_HISR) from the previous data block DMA
transfer should be cleared before the stream can be re-enabled."
        }, 
        action SetPeripheralPortRegisterAddress {
            name: "Set Peripheral Address"
            sequence: [
                setRegisterValues SET_SxPAR {
                    registerValues: [ST_F4_DMA_SxPAR_VALUE] 
                    optional: off
                }
            ]
            requiredState: ["Enabled", "0"]
            setsState: []
            meta: "Set the peripheral port register address in the DMA_SxPAR register. The data will be
# moved from/ to this address to/ from the peripheral port after the peripheral event."
        }, 
        action SetMemoryAddress0 {
            # DMA_CMARx register
            name: "Set Memory 0 Address"
            sequence: [
                setRegisterValues SET_SxMA0R {
                    registerValues: [ST_F4_DMA_SxM0AR_VALUE] 
                    optional: off
                }
            ]
            requiredState: ["Enabled", "0"]
            setsState: []
            meta: "Set the memory address in the DMA_SxMA0R register (and in the DMA_SxMA1R
# register in the case of a double buffer mode). The data will be written to or read from
# this memory after the peripheral event."
        }, 
        action SetTransferSize {
            name: "Set Trasnfer Size"
            sequence: [
                setRegisterValues SET_SxNDTR {
                    registerValues: [ST_F4_DMA_SxNDTR_NDT_VALUE] 
                    optional: off
                }
            ]
            requiredState: ["Enabled", "0"]
            setsState: []
            meta: "Configure the total number of data items to be transferred in the DMA_SxNDTR
# register. After each peripheral event or each beat of the burst, this value is
# decremented"
        }, 
        action SelectDMAChannel {
            name: "Select DMA Channel"
            sequence: [
                setRegisterValues SET_CHSEL {
                    registerValues: [ST_F4_DMA_SxCR_CHSEL_VALUE] 
                    optional: off
                }
            ]
            requiredState: ["Enabled", "0"]
            setsState: []
            meta: "Select the DMA channel (request) using CHSEL[2:0] in the DMA_SxCR register."
        }, 
        action SetPeripheralFlowControl {
            name: "Set Peripheral Flow Control"
            sequence: [
                setRegisterValues SET_PFCTRL {
                    registerValues: [ST_F4_DMA_SxCR_PFCTRL_VALUE] 
                    optional: off
                }
            ]
            requiredState: ["Enabled", "0"]
            setsState: []
            meta: "If the peripheral is intended to be the flow controller and if it supports this feature, set
# the PFCTRL bit in the DMA_SxCR register."
        }, 
        action SetPriority {
            name: "Set Priority"
            sequence: [
                setRegisterValues SET_PL {
                    registerValues: [ST_F4_DMA_SxCR_PL_VALUE] 
                    optional: off
                }
            ]
            requiredState: ["Enabled", "0"]
            setsState: []
            meta: "Configure the stream priority using the PL[1:0] bits in the DMA_SxCR register."
        }, 
        action ConfigureFIFO {
            name: "Configure FIFO"
            sequence: [
                setRegisterValues CONFIG_FIFO {
                    registerValues: [ST_F4_DMA_SxFCR_DMDIS_VALUE, ST_F4_DMA_SxFCR_FTH_VALUE ] 
                    optional: off
                }
            ]
            requiredState: ["Enabled", "0"]
            setsState: []
            # TODO Is there a register to enable the FIFO? I can find it....
            meta: "Configure the FIFO usage (enable or disable, threshold in transmission and reception)"
        }, 
        action SetTransferDirection {
            name: "Set Transfer Direction"
            sequence: [
                setRegisterValues SET_ {
                    registerValues: [ST_F4_DMA_SxNDTR_NDT_VALUE] 
                    optional: off
                }
            ]
            requiredState: ["Enabled", "0"]
            setsState: []
            meta: "Configure the data transfer direction, peripheral and memory incremented/fixed mode,
single or burst transactions, peripheral and memory data widths, Circular mode, Double buffer mode and interrupts after half and/or full transfer, and/or errors in the
DMA_SxCR register."
        }, 
        action ActivateStream {
            name: "Activate Stream"
            sequence: [
                putRegisterValues ENABLE_DMA {
                    registerValues: [ST_F4_DMA_SxCR_EN_VALUE] 
                    optional: off
                    value: 1
                }
            ]
            requiredState: ["Enabled", "0"]
            setsState: ["Enabled", "1"]
            meta: "Activate the stream by setting the EN bit in the DMA_SxCR register."
        }
    ]
    meta: ''
}